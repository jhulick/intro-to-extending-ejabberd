<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Introduction to Extending eJabberd</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="software/reveal.js/css/reveal.min.css">
		<link rel="stylesheet" href="software/reveal.js/css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="software/reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="software/reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="software/reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>Introduction to Extending eJabberd</h1>
					<h3>Using Erlang for the first time</h3>
					<p>
          <small><a href="http://github.com/kyleburton"><span data-title="Kyle Burton">Kyle Burton</span></a> / <a href="http://twitter.com/kyleburton"><span data-title="@kyleburton">@kyleburton</span></a></small>
					</p>
				</section>

				<section>
					<h2>Incorporate Chat Into Our Product</h2>
					<ul>
						<li>Quickly: Use Standard Software</li>
						<li>Be Robust: Support Clustering and HA</li>
						<li>Support multi-person Rooms</li>
					</ul>

					<aside class="notes">
						These were our requirements.
					</aside>
				</section>

				<section>
					<h2>eJabberd</h2>
          <p>
            Met all of our initial requirements, then things changed...
          </p>

					<aside class="notes">
						Time went by.
					</aside>
				</section>

				<section>
					<h2>eJabberd Extended</h2>
          <ul>
            <li>See who is in a room</li>
            <li>Peek at the messages in a room</li>
            <li>Post a message to a room on behalf of a user</li>
            <li>Pre-create Rooms</li>
            <li>Create user credentials</li>
          </ul>

					<aside class="notes">
            <p>
            If there is no counter party in the room for the user, we actively try to find one
            that is on-call and assign them to the room.
            </p>
            <p>
            We wanted to write tests for our software, ensuring that responses
            and auto-responses worked as intended.  To do this we needed to be able
            to see what was in the room without having to write a full blown XMPP client.
            </p>
            <p>
            We were integrating SMS as a channel into the chat room, 
            </p>
					</aside>
				</section>

				<section>
					<h2>Choices Choices</h2>
          <p>
          Do we use the existing tools and extend XMPP itself?  
          
          </p>
          <p>
          Do we create an alternate interface into eJabberd's
          internals?
          </p>

					<aside class="notes">
						Time went by.
					</aside>
				</section>

				<section>
					<h2>1: Extend XMPP</h2>
          <ul>
            <li>PRO: can use existing libs (bosh, smack)</li>
            <li>CON: smack is flaky from the JVM</li>
            <li>CON: normal users could make these calls</li>
            <li>CON: may break standard clients (pidgin)</li>
            <li>CON: mod_muc prevents the same user from joining the room multiple times (dealbreaker!)</li>
          </ul>

					<aside class="notes">
          The last one was a dealbreaker for us, we have a distributed,
          concurrent system, we need to be able to execute these new features
          from multiple application servers, perhaps concurrently.
					</aside>
				</section>

				<section>
					<h2>2: REST Api</h2>
          <ul>
            <li>PRO: easy to call into from the JVM</li>
            <li>PRO: easy to map actions to RESTful URLs</li>
            <li>PRO: mod_restul_admin has 1 of our required features already</li>
            <li>CON: have to hack Erlang (PRO)</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>REST Api, I choose you!</h2>
          <p>
          Simplicity wins.
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>eJabberd Internals</h2>
          <p>
            eJabberd is built on Erlang's OTP Behaviors
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>OTP Behaviors</h2>
          <ul>
            <li>gen_sever</li>
            <li>gen_fsm</li>
            <li>gen_event</li>
            <li>supervisor</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>gen_fsm</h2>
          <br />
          <p>
          mod_muc_room is a gen_fsm.
          </p>
          <br />
          <p>
            It has a state which contains what we need:
          </p>
          <br />
          <ul>
            <li>list of users</li>
            <li>message history</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>What now?</h2>
          <p>
          All the pieces were now laid out for us, so how do we hack eJabberd and Erlang?
          </p>
          <p>
          A strange new world awaited us...
          </p>

					<aside class="notes">
						notes
					</aside>
				</section>

				<section>
					<h2>Erlang: Language Semantics</h2>
          <ul>
            <li>Expression Based</li>
            <li>Single Assignment, [generally] Immutable Types</li>
            <li>Pattern Matching and Destructuring</li>
            <li>Function Clauses</li>
            <li>Syntax: comma, semi-colon; and period.</li>
            <li>Data Types: atoms, numbers, lists, tuples, binaries, pid, function</li>
            <li><u>There is no <b><i>String</i></b> type!</u></li>
          </ul>

          <aside class="notes">
          <code>
            what is a string in Erlang?  a list of integers. <br />
            The repl will display a list as text if all the ints look like ascii values(!) <br />
            Demonstrate binary <br />
            &lt;&lt;"foof"&gt;&gt;.<br />
            different from a string (list of ints). <br />
            list_to_binary("this is a string").<br />
            binary_to_list(<<"this is a string">>).<br />
          </code>
					</aside>
				</section>

				<section>
					<h2>Erlang: Runtime Semantics</h2>
          <ul>
            <li>iolists</li>
            <li>recursion and process state</li>
            <li>processes</li>
            <li>message passing</li>
            <li>the mnesia distributed database</li>
            <li>code path</li>
            <li>hot reloading code</li>
            <li>upgrading a process</li>
          </ul>

					<aside class="notes">
          <code>

          iolists are a list of ints or binaries, sockets and files support writing iolists natively, and they're easy to construct in code, they can easily be built out of maps, folds and recursions over your data without having to flatten the structure for output. <br />
          they also have the advantage that you're not allocating as much new memory as you would if you were doing string concatnation or building up a buffer (eg: Java's StringBuilder or StringBuffer).<br />
          Demonstrate iolists at the repl <br />
          io_lib:format("this: ~p~n", [{this,[1,2,3,{thing,is,"what I'm talking about"}]}]).</br>
          iolist_to_binary([1,2,3,"this","that"]). <br />
          binary_to_list(iolist_to_binary([1,2,3,"this","that"])). <br />
          </code>
					</aside>
				</section>

				<section>
					<h2>Lessons Learned</h2>
          <ul>
            <li>Erlang Cookie</li>
            <li>proplists</li>
            <li>JSON in a land with no string</li>
            <li>REPL</li>
            <li>Remote Shell</li>
            <li><code>ejabberdctl live</code></li>
            <li>mod_restful_debug</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>Lesson: Cookie</h2>
          <p>
          ejabberd didn't use
          </p> <br />
          <p>
          <code>$HOME/.erlang.cookie</code>
          </p> <br />
          <p>like all the other kids, it used
          </p> <br />
          <p>
          <code>/var/lib/ejabberd/.erlang.cookie</code>
          </p> <br />
          <p>
          instead :/
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>proplists</h2>
					<pre><code contenteditable>
          [
            {route, "/api/admin"},
            {listen, "127.0.0.1"},
            {port, 8088},
            {api_key, "1tm6q0zy5lx5bj4.13h5rkokul2oqax8"},
            {access_log, "/var/log/ackerman/access.log"},
            {error_log, "/var/log/ackerman/error.log"}

          ]
					</code></pre>

					<aside class="notes">
						...
					</aside>
				</section>


				<section>
					<h2>JSON</h2>
          <p>
          <code>mod_restful_mochijson2</code> was hard for us to see how it worked.
          </p>
          <p>
          Not having the <code>string==list(integer)</code> equivalence in our heads added to the confusion.
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>REPL</h2>
          <p>
            Having access to Erlang's repl was nice, but...
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>ejabberdctl debug</h2>
          <p>
          Having a remote shell that was directly interacting with the server was even better.
          </p>
          <p>
          Between the remote shell and our debugging service, it was almost like swank.
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>ejabberdctl live</h2>
          <p>
            This runs ejabberd in the foreground, not as a daemon.  This was invaluable when we broke the service at startup:
          </p>
          <ul>
            <li>we borked the configuration file</li>
            <li>we messed up the nodename and couldn't connect the debug console</li>
            <li>we tried to call a module:function that didn't exist.</li>
          </ul>

					<aside class="notes">
						It turns out that Erlang uses late binding and allows you to call modules and functions dynamically at runtime, even via variables.  This is useful, but it means that you may not find out that you typo'd a function or module name until you run the code.
					</aside>
				</section>

				<section>
					<h2>Hotloading Code</h2>
          <p>
          Recompile, copy the *.beam files into the proper place and then:
          </p>
          <p>
          <code>l(module_name).</code>
          </p>
          <p>
          <code>nl(module_name).</code>
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>mod_restful_debug</h2>
          <br/>
					<pre><code contenteditable>
  % at the debug remote shell
  mod_restful_debug:start().

  post_message_to_room(RoomName, From, Message) ->
    mod_restful_debug:store(post_message_params,[RoomName, From, Message]).
    ...

  % at the debug remote shell
  mod_restful_debug:lookup(post_message_params).
					</code></pre>

					<aside class="notes">
          <p>
          We wrote a simple <code>gen_server</code> that held a dictionary so we could message it to store or retrieve data.  We then used this from inside the other code to capture values, and with <code>ejabberdctl debug</code> we could query and see the values.
          </p>
          <p>
          This was a huge help to our productivity.
          </p>
					</aside>
				</section>


				<section>
					<h2>Demo</h2>
          <p>
            (Go flail on the keyboard and make mistakes.)
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
          <ul style="list-style-type: none;">
            <li>&#x2713; Extend Ejabberd</li>
            <li>&#x2713; Add Modules</li>
            <li>&#x2713; Code, Reload and Interact</li>
            <li>&#x2717; mod_muc_room's history in ram == no persistance :(</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>


				<section>
          <p style="font-size: 10em;">?</p>

					<aside class="notes">
						...
					</aside>
				</section>


				<section>
					<h2>Thank You!</h2>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>References</h2>
          <ul>
            <li>github.com/kyleburton/intro-to-extending-ejabberd</li>
            <li>erlang docs: http://www.erlang.org/doc/</li>
            <li>iolists: http://prog21.dadgum.com/70.html</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>

			</div>

		</div>

    <!--
    <footer style="clear: both; display: block; position: absolute; bottom: 0; width: 100%; height: 2em;">
      <div style="text-align: center; color: white; font-size: 1.5em;">
        <a href="http://twitter.com/kyleburton">@kyleburton</a> / <a href="http://github.com/kyleburton">github.com/kyleburton</a>
      </div>
    </footer>
    -->

		<script src="software/reveal.js/lib/js/head.min.js"></script>
		<script src="software/reveal.js/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'software/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'software/reveal.js/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'software/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'software/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'software/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'software/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'software/reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'software/reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
