<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Introduction to Extending ejabberd</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="software/reveal.js/css/reveal.min.css">
		<link rel="stylesheet" href="software/reveal.js/css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="software/reveal.js/lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="software/reveal.js/css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="software/reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>Introduction to Extending ejabberd</h1>
					<h3>Using Erlang for the first time</h3>
					<p>
          <small><a href="http://github.com/kyleburton"><span data-title="Kyle Burton">Kyle Burton</span></a> / <a href="http://twitter.com/kyleburton"><span data-title="@kyleburton">@kyleburton</span></a></small>
					</p>
				</section>

				<section>
					<h1>Hi</h1>
          <small><p>I'm Kyle Burton,</p><p>the Head of Technology @ Relay Network</p></small>
				</section>

				<section>
					<h2>Incorporate Chat</h2>
					<ul style="list-style-type: none;">
						<li>Quickly &rarr; Use Standard Software</li>
						<li>Be Robust &rarr; Support Clustering and HA</li>
						<li>Need &rarr; Support multi-person Chat Rooms</li>
					</ul>

					<aside class="notes">
            We wanted to incorporate chat into our product.
						These were our initial requirements.
					</aside>
				</section>

				<section>
					<h2>ejabberd</h2>
          <ul style="list-style-type: none;">
            <li>&nbsp;</li>
            <li>&#x2713; Off the shelf</li>
            <li>&#x2713; supports clustering and HA</li>
            <li>&#x2713; suports rooms</li>
            <li>&nbsp;</li>
            <li>All good then&trade;?</li>
          </ul>

					<aside class="notes">
						Off the shelf
					</aside>
				</section>

				<section>
          <section>
          <p>
          ejabberd met all of our <i><u>initial</u></i> requirements&hellip;
          </p>

          <p>
          &darr;
          </p>

          <aside class="notes">
          Time went by.
          </aside>
          </section>

          <section class="future">
          <p>Of course then things changed.</p>
          </section>
        </section>

				<section>
					<h2>non-standard</h2>
          <ul style="list-style-type: none;">
            <li>&nbsp;</li>
            <li>&rarr; See who is in a room</li>
            <li>&rarr; Peek at the messages in a room</li>
            <li>&rarr; Post a message to a room on behalf of a user</li>
            <li>&rarr; Pre-create Rooms</li>
            <li>&rarr; Create and update user credentials</li>
            <li>&nbsp;</li>
            <li>Without being connected or showing up in the room.</li>
          </ul>

					<aside class="notes">
            <p>
            Many of these features were necessary in order for us to test the software.
            Some of these are supported by XMPP, but writing code against a
            synchronous (RESTful) api is simpler.
            </p>
            <p>
            If there is no counter party in the room for the user, we actively try to find one
            that is on-call and assign them to the room.
            </p>
            <p>
            We wanted to write tests for our software, ensuring that responses
            and auto-responses worked as intended.  To do this we needed to be able
            to see what was in the room without having to write a full blown XMPP client.
            </p>
            <p>
            We were integrating SMS as a channel into the chat room, 
            </p>
					</aside>
				</section>

				<section>

          <p>
					<h2 style="text-transform: none;">mod_restful_admin</h2>
          </p>

          <ul style="list-style-type: none;">
            <li>&nbsp;</li>
            <li>&#x2713; Already Exists</li>
            <li>&#x2713; RESTful Design</li>
            <li>&#x2713; Already Supports Create user credentials</li>
            <li>&nbsp;</li>
            <li>At first glance it looked easy to extend</li>
          </ul>

					<aside class="notes">
						Time went by.
					</aside>
				</section>


				<section>
					<h2>ejabberd Internals</h2>
          <ul style="list-style-type: none;">
            <li>&nbsp;</li>
            <li>&#x2717; ejabberd is written in Erlang</li>
            <li>&#x2717; ejabberd is built on OTP Behaviors</li>
            <li>&nbsp;</li>
            <li>I think I saw a spare Erlang in the back room.</li>
          </ul>

					<aside class="notes">
						No one on my team had worked with Erlang before.  It is brand new to our team.
					</aside>
				</section>

				<section>
					<h2>OTP Behaviors</h2>
          <ul style="list-style-type: none;">
            <li>&#x2717; gen_sever</li>
            <li>&#x2713; gen_fsm</li>
            <li>&#x2717; gen_event</li>
            <li>&#x2717; supervisor</li>
          </ul>

					<aside class="notes">
						The only behavior we need to talk about is gen_fsm, which is for creating finite state machines.  It turns out...
					</aside>
				</section>

				<section>
					<h2 style="text-transform: none;">gen_fsm</h2>
          <br />
          <p>
          mod_muc_room is a gen_fsm.
          </p>
          <br />
          <p>
            the room state contains:
          </p>
          <br />
          <ul style="list-style-type: none;">
            <li>&#x2713;list of users</li>
            <li>&#x2713;message history</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>What now?</h2>
          <p>
          All the pieces were now laid out for us, so how do we hack ejabberd and Erlang?
          </p>
          <p>
          A strange new world awaited us...
          </p>

					<aside class="notes">
						notes
					</aside>
				</section>

				<section>
					<h2>Language Semantics</h2>
          <!--<ul style="list-style-type: none;">-->
          <ul>
            <li>Expression Based</li>
            <li>Single Assignment, Immutable Default Types</li>
            <li>Pattern Matching and Destructuring</li>
            <li>Function Clauses</li>
            <li>Syntax: comma, semi-colon; and period.</li>
            <li>Data Types: atoms, numbers, lists, tuples, binaries, pid, function</li>
            <li><u>There is no <b><i>String</i></b> type!</u></li>
          </ul>

          <aside class="notes">
          <code>
            My team has a good bit of experience with a functional language,
            some of these concepts were familliar to us, some were not.

            What is a string in Erlang?  _a list of integers_! <br />

            The repl will display a list as text if all the ints look like ascii values(!) <br />

            Demonstrate binary <br />
            &lt;&lt;"foof"&gt;&gt;.<br />
            different from a string (list of ints). <br />
            list_to_binary("this is a string").<br />
            binary_to_list(<<"this is a string">>).<br />
          </code>
					</aside>
				</section>

				<section>
					<h2>Runtime Semantics</h2>
          <ul>
            <li>iolists</li>
            <li>recursion and process state</li>
            <li>processes</li>
            <li>message passing</li>
            <li>the mnesia distributed database</li>
            <li>code path</li>
            <li>hot reloading code</li>
            <li>upgrading a process</li>
          </ul>

					<aside class="notes">
          <code>

          iolists are a list of ints or binaries, sockets and files support writing iolists natively, and they're easy to construct in code, they can easily be built out of maps, folds and recursions over your data without having to flatten the structure for output. <br />
          they also have the advantage that you're not allocating as much new memory as you would if you were doing string concatnation or building up a buffer (eg: Java's StringBuilder or StringBuffer).<br />
          Demonstrate iolists at the repl <br />
          io_lib:format("this: ~p~n", [{this,[1,2,3,{thing,is,"what I'm talking about"}]}]).</br>
          iolist_to_binary([1,2,3,"this","that"]). <br />
          binary_to_list(iolist_to_binary([1,2,3,"this","that"])). <br />
          </code>
					</aside>
				</section>

				<section>
					<h2>Lessons Learned</h2>
          <ul>
            <li>Erlang Cookie</li>
            <li>proplists</li>
            <li>JSON in a land with no string</li>
            <li>REPL</li>
            <li>Remote Shell</li>
            <li><code>ejabberdctl live</code></li>
            <li>mod_restful_debug</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>Lesson: Cookie</h2>
          <p>
          ejabberd didn't use
          </p> <br />
          <p>
          <code>$HOME/.erlang.cookie</code>
          </p> <br />
          <p>like all the other kids, it used
          </p> <br />
          <p>
          <code>/var/lib/ejabberd/.erlang.cookie</code>
          </p> <br />
          <p>
          instead :/
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>Lesson: proplists</h2>
					<pre><code contenteditable>
          [
            {route, "/api/admin"},
            {listen, "127.0.0.1"},
            {port, 8088},
            {api_key, "1tm6q0zy5lx5bj4.13h5rkokul2oqax8"},
            {access_log, "/var/log/ackerman/access.log"},
            {error_log, "/var/log/ackerman/error.log"}

          ]
					</code></pre>

					<aside class="notes">
          Erlang doesn't have syntax for a map like Ruby, Perl and Clojure do.  
          The convention is to use what are called proplists.  proplists are a list
          of two-tuples where the first part is an atom and the second is any value.
          If you squint just right at one of these it looks like a key/value map.
					</aside>
				</section>


				<section>
					<h2>Lesson: JSON</h2>
          <br/>
          <p>
          Not easy for us to understand <code>mod_restful_mochijson2</code>
          </p>
          <br/>
          <p>
          Not having the</p>
          <code>string==list(integer)</code>
          </p>
          equivalence in our heads added to the confusion.
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>REPL</h2>
          <p>
            Having access to Erlang's repl was nice, but...
          </p>

					<aside class="notes">
            I like langauges that let you expirement and evolve you code.  I
            tend to like REPLs (Read Eval Print Loop).
					</aside>
				</section>

				<section>
					<h2>ejabberdctl debug</h2>
          <p>
          Having a remote shell that was directly interacting with the server was sublime.
          </p>
          <p>
          Between the remote shell and our debugging service, it was almost like swank.
          </p>

					<aside class="notes">
            Swank is part of the IDE we use for Clojure that lets us connect
            our IDE to a running application that we don't shut down.
					</aside>
				</section>

				<section>
					<h2>ejabberdctl live</h2>
          <p>
            This runs ejabberd in the foreground, not as a daemon.  This was invaluable when we broke the service at startup:
          </p>
          <ul style="list-style-type: none;">
            <li>&nbsp;</li>
            <li>&#x2717; we borked the configuration file</li>
            <li>&#x2717; we messed up the nodename and couldn't run the console</li>
            <li>&#x2717; we tried to call a module:function that didn't exist</li>
            <li>&nbsp;</li>
            <li>&#x2713; we <u>never</u> crashed ejabberd</li>
          </ul>

					<aside class="notes">
						It turns out that Erlang uses late binding and allows you to call modules and functions dynamically at runtime, even via variables.  This is useful, but it means that you may not find out that you typo'd a function or module name until you run the code.
					</aside>
				</section>

				<section>
					<h2>Hotloading Code</h2>
          <p>
          Recompile, copy the *.beam files into the proper place and then:
          </p>
          <p>
          <code>l(module_name).</code>
          </p>
          <p>
          <code>nl(module_name).</code>
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>mod_restful_debug</h2>
          <br/>
					<pre><code contenteditable>
  % at the debug remote shell
  mod_restful_debug:start().

  post_message_to_room(RoomName, From, Message) ->
    mod_restful_debug:store(post_message_params,[RoomName, From, Message]).
    ...

  % at the debug remote shell
  mod_restful_debug:lookup(post_message_params).
					</code></pre>

					<aside class="notes">
          <p>
          We wrote a simple <code>gen_server</code> that held a dictionary so we could message it to store or retrieve data.  We then used this from inside the other code to capture values, and with <code>ejabberdctl debug</code> we could query and see the values.
          </p>
          <p>
          This was a huge help to our productivity.
          </p>
					</aside>
				</section>


				<section>
					<h2>Demo</h2>
          <p>
            (Go flail on the keyboard and make mistakes.)
          </p>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
          <ul style="list-style-type: none;">
            <li>&#x2713; Extend Ejabberd</li>
            <li>&#x2713; Add Modules</li>
            <li>&#x2713; Code, Reload and Interact</li>
            <li>&#x2717; mod_muc_room's history in ram == no persistance :(</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>


				<section>
          <p style="font-size: 10em;">?</p>

					<aside class="notes">
						...
					</aside>
				</section>


				<section>
					<h2>Thank You!</h2>

					<aside class="notes">
						...
					</aside>
				</section>

				<section>
					<h2>References</h2>
          <ul>
            <li>github.com/kyleburton/intro-to-extending-ejabberd</li>
            <li>erlang docs: http://www.erlang.org/doc/</li>
            <li>iolists: http://prog21.dadgum.com/70.html</li>
          </ul>

					<aside class="notes">
						...
					</aside>
				</section>

			</div>

		</div>

    <!--
    <footer style="clear: both; display: block; position: absolute; bottom: 0; width: 100%; height: 2em;">
      <div style="text-align: center; color: white; font-size: 1.5em;">
        <a href="http://twitter.com/kyleburton">@kyleburton</a> / <a href="http://github.com/kyleburton">github.com/kyleburton</a>
      </div>
    </footer>
    -->

		<script src="software/reveal.js/lib/js/head.min.js"></script>
		<script src="software/reveal.js/js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'software/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'software/reveal.js/plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'software/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'software/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'software/reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'software/reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'software/reveal.js/plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'software/reveal.js/plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
